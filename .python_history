exampletext = "!oopa yo"
exampletest.split(!)
exampletest.split("!")
exampletext = "!oopa yo" 
exampletext
exampletext.split()
exampletext.split("!")
exampletext.split(:1)
exampletext.[1:].split()
exampletext[1:].split()
exampletext[1:].split()[0]
exit
exit()
import cmd, sys
from turtle import *
class TurtleShell(cmd.Cmd):
    intro = 'Welcome to the turtle shell.   Type help or ? to list commands.\n'
    prompt = '(turtle) '
    file = None
    # ----- basic turtle commands -----
    def do_forward(self, arg):
        'Move the turtle forward by the specified distance:  FORWARD 10'
        forward(*parse(arg))
    def do_right(self, arg):
        'Turn turtle right by given number of degrees:  RIGHT 20'
        right(*parse(arg))
    def do_left(self, arg):
        'Turn turtle left by given number of degrees:  LEFT 90'
        left(*parse(arg))
    def do_goto(self, arg):
        'Move turtle to an absolute position with changing orientation.  GOTO 100 200'
        goto(*parse(arg))
    def do_home(self, arg):
        'Return turtle to the home position:  HOME'
        home()
    def do_circle(self, arg):
        'Draw circle with given radius an options extent and steps:  CIRCLE 50'
        circle(*parse(arg))
    def do_position(self, arg):
        'Print the current turtle position:  POSITION'
        print('Current position is %d %d\n' % position())
    def do_heading(self, arg):
        'Print the current turtle heading in degrees:  HEADING'
        print('Current heading is %d\n' % (heading(),))
    def do_color(self, arg):
        'Set the color:  COLOR BLUE'
        color(arg.lower())
    def do_undo(self, arg):
        'Undo (repeatedly) the last turtle action(s):  UNDO'
    def do_reset(self, arg):
        'Clear the screen and return turtle to center:  RESET'
        reset()
    def do_bye(self, arg):
        'Stop recording, close the turtle window, and exit:  BYE'
        print('Thank you for using Turtle')
        self.close()
        bye()
        return True
    # ----- record and playback -----
    def do_record(self, arg):
        'Save future commands to filename:  RECORD rose.cmd'
        self.file = open(arg, 'w')
    def do_playback(self, arg):
        'Playback commands from a file:  PLAYBACK rose.cmd'
        self.close()
        with open(arg) as f:
            self.cmdqueue.extend(f.read().splitlines())
    def precmd(self, line):
        line = line.lower()
        if self.file and 'playback' not in line:
            print(line, file=self.file)
        return line
    def close(self):
        if self.file:
            self.file.close()
            self.file = None
def parse(arg):
    'Convert a series of zero or more numbers to an argument tuple'
    return tuple(map(int, arg.split()))
if __name__ == '__main__':
    TurtleShell().cmdloop()
quit
help
list
quit
file = open("deletelater.txt","w")
file.write("Hello World!")
file.close()
print(file)
file.write(âHello Worldâ) 
file.write(âThis is our new text fileâ) 
file.write(âand this is another line.â) 
exit()
print("ok")
file = open("deletelater.txt","w")
file.write(âH"llo Worldâ")
file.write(âe.write("Hello World!")
file.write("Hello World!")
file.write("bleh")
file.close()
exit()
Main.py &
Main.py
classic.py
help
help()
keywords
rsys.argv
import rpyc
conn = rpyc.classic.connect("localhost")
rsys = conn.module.sys
rsys = conn.modules.sys
minidom = conn.modules["xml.dom.minidom"]
rsys.argv
conn.modules.os.chdir("..")
print("Hello World!", file=conn.modules.sys.sdout)
print("Hello World!", file=conn.modules.sys.stdout)
f = conn.builtins.open("testing.py")
conn.modules.os.chdir("app")
f = conn.builtins.open("testing.py")
f.read()
conn.execute("import math")
conn.eval("2*math.pi")
conn.namespace
conn.builtins.compile()
conn.modules.builtins.compile()
def square(x):
return x**2
	return x**2
return x**2
def square(x):
	return x**2
fn = conn.teleport(square)
conn
fn = conn.teleport(square)
conn.eval("2*math.pi")
conn.eval("square(3)")
def square(x):
	return x**2
square
fn
fn = conn.teleport(square)
conn.eval("square(3)")
square
square()
square(3)
conn.eval('square(3)')
conn.namespace["square"] is fn
square
square(3)
conn.teleport(square)
import rpyc
conn = rpyc.classic.connect("localhost")
rsys = conn.modules.sys
conn.modules["xml.dom.minidom"]
minidom = conn.modules["xml.dom.minidom"]
print ("Yuppers.", file = conn.modules.sys.stout)
print ("Yuppers.", file = conn.modules.sys.stdout)
import rpyc
conn = rpyc.classic.connect("localhost")
type(conn.modules.sys)
type(conn.modules.sys.path)
type(conn.modules.sys.abspath)
type(conn.modules.os.path.abspath)
isinstance(conn.modules.sys.path, list)
import inspect
inspect.isbuiltin(conn.modules.os.listdir)
inspect.isfunction(conn.modules.os.path)
inspect.isfunction(conn.modules.os.path.abspath)
inspect.ismethod(conn.modules.os.path.abspath)
inspect.ismethod(conn.modules.sys.stdout.write)
dir(conn.modules.sys.path)
conn.modules.sys.path[300]
import rpyc
c = rpyc.connect("localhost", 18861)
c.root
c.root.get_answer()
c.root.the_real_answer_though
c.root.get_question()
c.root
import rpyc
from rypc.utils.server import ThreadedServer
from rpyc.utils.server import ThreadedServer
exit()
import rpyc
c = rpyc.classic.connect("localhost")
rlist = c.modules.__builtin__.range(10)
rlist = c.modules.builtin.range(10)
rlist = c.modules.builtins.range(10)
rlist
def f(x):
	return x**2
map(f, range(10))
c
rlist = c.modules._builtin_.range(10)
exit()
import rpyc
c = rpyc.classic.connect("localhost")
c.modules.time.sleep
c.modules.time.sleep(2)
asleep = rpyc.async_(c,modules.time.sleep)
asleep = rpyc.async_(c.modules.time.sleep)
asleep
res = sleep(15)
res = asleep(15)
res
res.ready
print res.value
print (res.value)
res
aint = rpyc.async_(c.modules.__builtin__.int)
aint = rpyc.async_(c.modules.builtins.int)
x = aint("8")
x
x.ready
x.error
x.value
x = aint("jdfjd")
x.ready
x.error
x.value
x.value #
rpyc.utils.classic.teleport_function(def():\nraise KeyboardInterrupt)
rpyc.utils.classic.teleport_function(c,def():\nraise KeyboardInterrupt)
rpyc.utils.classic.teleport_function(c,\nraise KeyboardInterrupt)
import rpyc
f = open("floop.bloop", "w")
conn = rpx.connect("localhost", 18871)
conn = rpc.connect("localhost", 18871)
conn = rpyc.connect("localhost", 18871)
bgsrv = rpyc.BgServingThread(conn)
def on_file_changed(oldstat, newstat):
	print("File changed")
	print("    old stat: %s" % (oldstat,)
	print("    new stat: %s" % (newstat,)
def on_file_changed(oldstat, newstat):
	print("File changed")
	print("    old stat: %s" % (oldstat,)
\
/
def on_file_changed(oldstat, newstat):
	print("File changed")
	print("    old stat: %s" % (oldstat,))
	print("    new stat: %s" % (newstat,))
mon = conn.root.FileMonitor("floop.bloop", on_file_changed)
conn.root
mon = conn.root.FileMonitorService.FileMonitor("floop.bloop", on_file_changed)
bgsrv
mon = conn.root.FileMonitor("floop.bloop", on_file_changed)
FileMonitor
FileMonitorService
conn.root
mon = conn.root.FileMonitor("floop.bloop", on_file_changed)
mon = conn.root.FileMonitor.FileMonitor("floop.bloop", on_file_changed)
mon = conn.root.FileMonitorService.FileMonitor("floop.bloop", on_file_changed)
mon = conn.root.FileMonitor("floop.bloop", on_file_changed)
conn.root
c.root
conn.root
monn = conn.root__main__.FileMonitorService.FileMonitor("floop.bloop", on_file_changed)
monn = conn.root.__main__.FileMonitorService.FileMonitor("floop.bloop", on_file_changed)
conn
conn2
conn
conn.root
conn.root.FileMonitorService
conn.root.FileMonitor
conn.root.FileMonitor()
conn.root.FileMonitorService()
FileMonitor()
root.FileMonitor()
conn.FileMonitor()
conn.root.FileMonitor()
conn.root.filename
import rpyc
f = open("floop.bloop", "w")
conn = rypc.connect("localhost", 18817)
conn = rpyc.connect("localhost", 18817)
import rpyc
conn = rpyc.connect("localhost", 18817)
conn = rpyc.connect("localhost", 18872)
conn
sys.stdout.flush()
exit()
import threading
class Foo (threading.Thread):
	def __init__(self,x):
		self.__x = x
		threading.Thread.__init__self()
	def run (self):
		print str(self.__x)
class Foo (threading.Thread):
	def __init__(self,x):
		self.__x = x
		threading.Thread.__init__self()
	def run (self):
		print (str(self.__x))
for x in xrange(20):
	Foo(x).start()
for x in range(20):
	Foo(x).start()
exit
exit()
import threading
class Foo (threading.Thread):
	def __init__(self,x):
		self.__x = x
		threading.Thread.__init__(self)
	def run (self):
		print (str(self.__x)
)
for x in range(20):
	Foo(x).start()
exit()
f = open("temp.txt", r)
f = open("temp.txt", "r")
print(f.read())
f.close()
c = open("logs.txt", "r")
print(c.read())
c.close()
exit()
f.open("logs.txt", "r")
f = open("logs.txt", "r")
print(f.read())
exit()
f = open("blacklist.txt", "r")
print(f.read())
exit()
